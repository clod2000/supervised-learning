{"cells":[{"cell_type":"markdown","metadata":{"id":"shbM3zJAuPI9"},"source":["In this lab you will do the following steps in order:\n","\n","1. Load and normalizing the CIFAR10 training and test datasets using\n","   ``torchvision``\n","2. Define a Convolution Neural Network\n","3. Define a loss function and optimizer\n","4. Train the network on the training data\n","5. Test the network on the test data\n","\n","Using ``torchvision``, itâ€™s extremely easy to load CIFAR10.\n","\n"]},{"cell_type":"markdown","metadata":{"id":"Qf9I_7NdzTf6"},"source":["How to install a different version of a package"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"S4ZhoQ3vuPI_"},"outputs":[],"source":["import torch\n","import torchvision\n","import torchvision.transforms as transforms"]},{"cell_type":"markdown","metadata":{"id":"6F0vCe0kzcJ9"},"source":["Use GPU if available"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"5bun1lQdwoqy","colab":{"base_uri":"https://localhost:8080/"},"outputId":"9d3e642d-6ae6-46ed-9884-4307b0b90e6c","executionInfo":{"status":"ok","timestamp":1712606114657,"user_tz":-120,"elapsed":3,"user":{"displayName":"Mirko Agarla","userId":"02007240672373134675"}}},"outputs":[{"output_type":"stream","name":"stdout","text":["CUDA is not available.  Training on CPU ...\n","cpu\n"]}],"source":["train_on_gpu = torch.cuda.is_available()\n","if not train_on_gpu:\n","    print('CUDA is not available.  Training on CPU ...')\n","else:\n","    print('CUDA is available!  Training on GPU ...')\n","device = torch.device(\"cuda:0\" if train_on_gpu else \"cpu\")\n","print(device)"]},{"cell_type":"markdown","metadata":{"id":"dZyKEHctuPI_"},"source":["1. Load and normalizing the CIFAR10 training and test datasets using\n","   ``torchvision``\n","   \n","The output of [torchvision datasets](https://pytorch.org/vision/stable/datasets.html#datasets) are PILImage images of range [0, 1].\n","We [transform](https://pytorch.org/vision/stable/transforms.html) them to Tensors of normalized range [-1, 1]. Then we call the [dataloader](https://pytorch.org/docs/stable/data.html#torch.utils.data.DataLoader)\n","\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nV92dK3ruPI_"},"outputs":[],"source":[]},{"cell_type":"markdown","metadata":{"id":"5nB4FDsouPJA"},"source":["Let us [show](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html#matplotlib-pyplot-imshow) some of the training images\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"KVCb2s_QuPJA"},"outputs":[],"source":["import matplotlib.pyplot as plt  # Import library for plotting\n","import numpy as np  # Import library for numerical computations\n","from collections import Counter  # Import Counter for counting elements\n","\n","# Function to display an image\n","def imshow(image):\n","    mean=torch.tensor([0.485, 0.456, 0.406])\n","    std=torch.tensor([0.229, 0.224, 0.225])\n","\n","    # Unnormalize the image channels to [0, 1]\n","    image = image.mul(std.unsqueeze(1).unsqueeze(2))  # More efficient element-wise multiplication\n","    image = image.add(mean.unsqueeze(1).unsqueeze(2))  # Efficient element-wise addition\n","\n","    image= image.clamp(0, 1)\n","\n","    # Convert the tensor to a NumPy array\n","    npimg = image.numpy()\n","    # Plot the image using matplotlib\n","    plt.imshow(np.transpose(npimg, (1, 2, 0)))  # Transpose for correct display\n","\n","# ------------------ Train Loader Section ------------------\n","\n","print(\"Train loader:\")\n","\n","# Count the frequency of each class in the training set\n","stat = dict(Counter(trainset.targets))\n","\n","# Create a new dictionary with class names as keys\n","new_stat = stat.copy()\n","for k in stat.keys():\n","    new_stat[classes[k]] = stat[k]\n","    del new_stat[k]\n","\n","# Print the length of the train loader (number of batches)\n","print(len(trainloader))\n","\n","# Print the class distribution in the training set\n","print(new_stat)\n","\n","# Get a batch of random training images and their labels\n","dataiter = iter(trainloader)\n","images, labels = next(dataiter)\n","\n","# Print the shape of the image tensor (batch_size, channels, height, width)\n","print(images.shape)\n","\n","# Display the images using the imshow function\n","imshow(torchvision.utils.make_grid(images))\n","\n","# Print the labels of the images\n","print(' '.join('%s' % classes[labels[j]] for j in range(4)))  # Print labels for 4 images\n","\n","# ------------------ Test Loader Section ------------------\n","\n","print(\"\\nTest loader:\")\n","\n","# Similar steps for the test loader\n","stat = dict(Counter(testset.targets))\n","new_stat = stat.copy()\n","for k in stat.keys():\n","    new_stat[classes[k]] = stat[k]\n","    del new_stat[k]\n","\n","print(len(testloader))\n","print(new_stat)\n"]},{"cell_type":"markdown","metadata":{"id":"FWjfTuThuPJA"},"source":["2. Define a Convolution Neural Network.\n","[network layers](https://pytorch.org/docs/stable/nn.html#convolution-layers)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"8HW6XRf7uPJB"},"outputs":[],"source":[]},{"cell_type":"markdown","source":["Compute the receptive field of the network"],"metadata":{"id":"O2P0Zlbl2Stb"}},{"cell_type":"code","source":["# This line attempts to clone a Git repository using a shell command.\n","!git clone https://github.com/Fangyh09/pytorch-receptive-field.git\n","\n","# This line would move the downloaded directory\n","!mv -v pytorch-receptive-field/torch_receptive_field ./\n","\n","# Import the 'receptive_field' function from the 'torch_receptive_field' library.\n","from torch_receptive_field import receptive_field\n","\n","# Calculate the receptive field of the network 'net' for an input image size of\n","# 3 channels (RGB) and 32x32 pixels. The 'receptive_field' function would analyze the network architecture and input size to determine\n","# the receptive field size for each layer and the overall network.\n","receptive_field(net, input_size=(3, 32, 32))\n"],"metadata":{"id":"tsX3Q7q32SgF"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"hmA4DkACuPJB"},"source":["3. Define a loss function and optimizer\n","\n","Let's use a Classification [Cross-Entropy](https://pytorch.org/docs/stable/nn.html#loss-functions) loss and [SGD](https://pytorch.org/docs/stable/generated/torch.optim.SGD.html#torch.optim.SGD) with momentum.\n","\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"yl7S3NpruPJB"},"outputs":[],"source":[]},{"cell_type":"markdown","metadata":{"id":"bmu1-dvfuPJB"},"source":["4. Train the network on the training data\n","\n","\n","We simply have to loop over our data iterator, and feed the inputs to the\n","network and optimize.\n","\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"928O4nWYuPJC"},"outputs":[],"source":[]},{"cell_type":"markdown","metadata":{"id":"bzpMI9aUuPJC"},"source":["5. Test the network on the test data\n","\n","\n","We have trained the network for 2 passes over the training dataset.\n","But we need to check if the network has learnt anything at all.\n","\n","We will check this by predicting the class label that the neural network\n","outputs, and checking it against the ground-truth. If the prediction is\n","correct, we add the sample to the list of correct predictions.\n","\n","\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"e_JnNda2uPJD"},"outputs":[],"source":["# Initialize variables to track accuracy\n","correct = 0\n","total = 0\n","\n","# Disable gradient calculation for better performance during evaluation\n","with torch.no_grad():\n","    # Loop over the test loader\n","    for data in testloader:\n","        # Get the image and label from the current batch\n","        image, label = data\n","\n","        # Move the image data to the specified device (CPU or GPU)\n","        image = image.to(device)\n","\n","        # Get the network's prediction for the image\n","        output = net(image)\n","        # smax = torch.nn.Softmax(dim=1)(output.cpu())\n","\n","        # Find the class with the highest probability\n","        _, predicted = torch.max(output.cpu(), 1)  # Equivalent to pred = torch.argmax(output.cpu(), dim=1)\n","\n","        # Update total number of test images\n","        total += label.size(0)  # label.size(0) gives the batch size\n","\n","        # Count correct predictions\n","        correct += (predicted == label).sum().item()  # Count true positives\n","\n","# Calculate and print accuracy\n","print('Accuracy of the network on the 10000 test images: %d %%' % (\n","    100 * correct / total))\n"]},{"cell_type":"markdown","metadata":{"id":"O1Y4HMBOxCE6"},"source":["**!HOMEWORK!**"]},{"cell_type":"markdown","metadata":{"id":"mZW_s0fsB1Xi"},"source":["This homework assignment asks you to performs 2 tasks:\n","\n","1. Analyze Results with Different Network Parameters:\n","\n","This involves training the network with various configurations of network parameters and analyzing the impact on performance. Here's a step-by-step approach:\n","\n","**Choose Network Parameters:**\n","\n","Select the network parameters you want to experiment with. Common choices include:\n","\n","Number of layers: You can try increasing or decreasing the number of layers in your chosen network architecture (e.g., convolutional layers in a CNN).\n","Learning rate: Experiment with different learning rates (e.g., 0.01, 0.001, 0.0001) to find a balance between fast learning and stability.\n","Other parameters: Depending on your network architecture, there might be additional options like:\n","Number of filters in convolutional layers: This affects the complexity of features extracted from the data.\n","Activation functions: Experiment with different activation functions (e.g., ReLU, Leaky ReLU) to introduce non-linearity.\n","Optimizer parameters: Some optimizers (e.g., Adam) have hyperparameters you can adjust.\n","Train the network for a different number of epochs.\n","\n","**Analyze Results:**\n","\n","Compare the performance of the network across different parameter configurations:\n","\n","How accuracy/loss changes with different parameter values.\n","2. Show and Explain Errors of the Best Network:\n","\n","Once you identify the **best performing network configuration** (based on metrics like accuracy or loss), analyze its errors.\n","For example you can generate a confusion matrix. This matrix visualizes how often the network predicted each class correctly or incorrectly.\n","\n","Useful resources:\n","*   [network layers](https://pytorch.org/docs/stable/nn.html#convolution-layers)\n","*   [activation function](https://pytorch.org/docs/stable/nn.html#convolution-layers)\n","*   [loss functions](https://pytorch.org/docs/stable/nn.html#convolution-layers)\n","\n","\n","\n"]}],"metadata":{"colab":{"provenance":[]},"kernelspec":{"display_name":"Python 3","name":"python3"},"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.6.6"}},"nbformat":4,"nbformat_minor":0}